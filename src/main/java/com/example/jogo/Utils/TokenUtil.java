package com.example.jogo.Utils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTCreator;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.example.jogo.Entity.Member;
import org.bson.internal.Base64;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.Map;

/**
 * A utility class for token.
 *
 * @author Chenhan Huang
 * @since 2021.4.20
 */
@Component
public class TokenUtil {
    /** A string that will be used to encode the token */
    private static final String SECRET_KEY = "FU438F3HF98WHDASDHEKF8934FH";
    /** TTL(Time to Live) which means expireTime of token and timeUnit is millisecond */
    private static final int TTL = 2*60*60*1000;
    /** Who sign the token */
    private static final String ISSUER = "ADMIN";

    @Resource
    private RedisTemplate<String ,Object> redisTemplate;

    /**
     *
     * @param member object which requires authentication
     * @return token
     * @throws UnsupportedEncodingException using wrong algorithm when encoding
     */
    public String sign(Member member) throws UnsupportedEncodingException {
        Algorithm algorithm = Algorithm.HMAC256(SECRET_KEY);
        Date expireAt = new Date(System.currentTimeMillis()+TTL);
        String token;
        token = JWT.create()
                .withIssuer(ISSUER)
                .withClaim("username",member.getUsername())
                .withClaim("Serial",getRandomSerial(0,100))
                .withExpiresAt(expireAt)
                .sign(algorithm);
        return token;
    }

    /**
     *
     * @param member object which requires authentication
     * @param data data will be added into payload in form of key:value.
     * @return token
     * @throws UnsupportedEncodingException when encoding with wrong algorithm
     */
    public String sign(Member member, Map<String,String> data) throws UnsupportedEncodingException {
        Algorithm algorithm = Algorithm.HMAC256(SECRET_KEY);
        Date expireAt = new Date(System.currentTimeMillis()+TTL);
        JWTCreator.Builder builder = JWT.create().withIssuer(ISSUER).withClaim("username",member.getUsername())
                .withClaim("Serial",getRandomSerial(0,100))
                .withExpiresAt(expireAt);
        for(String key:data.keySet())
            builder.withClaim(key,data.get(key));
        return builder.sign(algorithm);
    }


    /**
     * check the validity of token
     * @param token token generated by calling {@link TokenUtil#sign(Member member)} )} or {@link TokenUtil#sign(Member member, Map data)}
     * @return the validity of token
     * @throws JWTVerificationException,UnsupportedEncodingException
     */
    public boolean verify(String token) throws JWTVerificationException,UnsupportedEncodingException{
        Algorithm algorithm = Algorithm.HMAC256(SECRET_KEY);
        DecodedJWT jwt = getVerifier().verify(token);

        return true;
    }

    /**
     *
     * @param token token generated by calling {@link TokenUtil#sign(Member member)} )} or {@link TokenUtil#sign(Member member, Map data)}
     * @param key field
     * @return value of key
     * @throws UnsupportedEncodingException,JWTVerificationException
     */
    public Object getDataFromPayLoad(String token,String key) throws UnsupportedEncodingException,JWTVerificationException{
            JWTVerifier verifier = getVerifier();
            DecodedJWT jwt = verifier.verify(token);
            String payLoad = jwt.getPayload();
            payLoad = new String(Base64.decode(payLoad), StandardCharsets.UTF_8);
            JSONObject json = JSON.parseObject(payLoad);
            return json.get(key);
    }

    private JWTVerifier getVerifier() throws UnsupportedEncodingException {
        return JWT.require(Algorithm.HMAC256(SECRET_KEY)).withIssuer(ISSUER).build();
    }

    /**
     * get a random number between min and max.
     * @param min minimum value of range
     * @param max maximum value of range
     * @return a random number between {@code min} and {@code max}
     */
    private int getRandomSerial(int min, int max){
        return (int)(Math.random()*(max-min)+min);
    }

    /**
     * @return TTL(time to live) which means expireTime of token
     */
    public static int getLiveTime(){
        return TTL;
    }
}
